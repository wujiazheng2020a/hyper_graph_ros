// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: base_geometry.proto

#ifndef PROTOBUF_INCLUDED_base_5fgeometry_2eproto
#define PROTOBUF_INCLUDED_base_5fgeometry_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_base_5fgeometry_2eproto 

namespace protobuf_base_5fgeometry_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_base_5fgeometry_2eproto
namespace tros {
namespace tros_base {
namespace geometry {
class Cone;
class ConeDefaultTypeInternal;
extern ConeDefaultTypeInternal _Cone_default_instance_;
class Extrusion;
class ExtrusionDefaultTypeInternal;
extern ExtrusionDefaultTypeInternal _Extrusion_default_instance_;
class Line;
class LineDefaultTypeInternal;
extern LineDefaultTypeInternal _Line_default_instance_;
class Oval;
class OvalDefaultTypeInternal;
extern OvalDefaultTypeInternal _Oval_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class PointCloud;
class PointCloudDefaultTypeInternal;
extern PointCloudDefaultTypeInternal _PointCloud_default_instance_;
class Polygen;
class PolygenDefaultTypeInternal;
extern PolygenDefaultTypeInternal _Polygen_default_instance_;
class Scene;
class SceneDefaultTypeInternal;
extern SceneDefaultTypeInternal _Scene_default_instance_;
class Shape;
class ShapeDefaultTypeInternal;
extern ShapeDefaultTypeInternal _Shape_default_instance_;
class Sphere;
class SphereDefaultTypeInternal;
extern SphereDefaultTypeInternal _Sphere_default_instance_;
class TransformationFrame;
class TransformationFrameDefaultTypeInternal;
extern TransformationFrameDefaultTypeInternal _TransformationFrame_default_instance_;
}  // namespace geometry
}  // namespace tros_base
}  // namespace tros
namespace google {
namespace protobuf {
template<> ::tros::tros_base::geometry::Cone* Arena::CreateMaybeMessage<::tros::tros_base::geometry::Cone>(Arena*);
template<> ::tros::tros_base::geometry::Extrusion* Arena::CreateMaybeMessage<::tros::tros_base::geometry::Extrusion>(Arena*);
template<> ::tros::tros_base::geometry::Line* Arena::CreateMaybeMessage<::tros::tros_base::geometry::Line>(Arena*);
template<> ::tros::tros_base::geometry::Oval* Arena::CreateMaybeMessage<::tros::tros_base::geometry::Oval>(Arena*);
template<> ::tros::tros_base::geometry::Point* Arena::CreateMaybeMessage<::tros::tros_base::geometry::Point>(Arena*);
template<> ::tros::tros_base::geometry::PointCloud* Arena::CreateMaybeMessage<::tros::tros_base::geometry::PointCloud>(Arena*);
template<> ::tros::tros_base::geometry::Polygen* Arena::CreateMaybeMessage<::tros::tros_base::geometry::Polygen>(Arena*);
template<> ::tros::tros_base::geometry::Scene* Arena::CreateMaybeMessage<::tros::tros_base::geometry::Scene>(Arena*);
template<> ::tros::tros_base::geometry::Shape* Arena::CreateMaybeMessage<::tros::tros_base::geometry::Shape>(Arena*);
template<> ::tros::tros_base::geometry::Sphere* Arena::CreateMaybeMessage<::tros::tros_base::geometry::Sphere>(Arena*);
template<> ::tros::tros_base::geometry::TransformationFrame* Arena::CreateMaybeMessage<::tros::tros_base::geometry::TransformationFrame>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tros {
namespace tros_base {
namespace geometry {

// ===================================================================

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tros.tros_base.geometry.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Point* other);
  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const final {
    return CreateMaybeMessage<Point>(NULL);
  }

  Point* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::google::protobuf::RepeatedField< float >&
      data() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_data();

  // float width = 2;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  float width() const;
  void set_width(float value);

  // @@protoc_insertion_point(class_scope:tros.tros_base.geometry.Point)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > data_;
  mutable int _data_cached_byte_size_;
  float width_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_base_5fgeometry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PointCloud : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tros.tros_base.geometry.PointCloud) */ {
 public:
  PointCloud();
  virtual ~PointCloud();

  PointCloud(const PointCloud& from);

  inline PointCloud& operator=(const PointCloud& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PointCloud(PointCloud&& from) noexcept
    : PointCloud() {
    *this = ::std::move(from);
  }

  inline PointCloud& operator=(PointCloud&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PointCloud& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointCloud* internal_default_instance() {
    return reinterpret_cast<const PointCloud*>(
               &_PointCloud_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PointCloud* other);
  friend void swap(PointCloud& a, PointCloud& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PointCloud* New() const final {
    return CreateMaybeMessage<PointCloud>(NULL);
  }

  PointCloud* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PointCloud>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PointCloud& from);
  void MergeFrom(const PointCloud& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointCloud* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tros.tros_base.geometry.Point points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  ::tros::tros_base::geometry::Point* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Point >*
      mutable_points();
  const ::tros::tros_base::geometry::Point& points(int index) const;
  ::tros::tros_base::geometry::Point* add_points();
  const ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Point >&
      points() const;

  // @@protoc_insertion_point(class_scope:tros.tros_base.geometry.PointCloud)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Point > points_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_base_5fgeometry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Line : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tros.tros_base.geometry.Line) */ {
 public:
  Line();
  virtual ~Line();

  Line(const Line& from);

  inline Line& operator=(const Line& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Line(Line&& from) noexcept
    : Line() {
    *this = ::std::move(from);
  }

  inline Line& operator=(Line&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Line& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Line* internal_default_instance() {
    return reinterpret_cast<const Line*>(
               &_Line_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Line* other);
  friend void swap(Line& a, Line& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Line* New() const final {
    return CreateMaybeMessage<Line>(NULL);
  }

  Line* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Line>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Line& from);
  void MergeFrom(const Line& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Line* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tros.tros_base.geometry.Point points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  ::tros::tros_base::geometry::Point* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Point >*
      mutable_points();
  const ::tros::tros_base::geometry::Point& points(int index) const;
  ::tros::tros_base::geometry::Point* add_points();
  const ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Point >&
      points() const;

  // float width = 2;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  float width() const;
  void set_width(float value);

  // @@protoc_insertion_point(class_scope:tros.tros_base.geometry.Line)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Point > points_;
  float width_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_base_5fgeometry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Polygen : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tros.tros_base.geometry.Polygen) */ {
 public:
  Polygen();
  virtual ~Polygen();

  Polygen(const Polygen& from);

  inline Polygen& operator=(const Polygen& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Polygen(Polygen&& from) noexcept
    : Polygen() {
    *this = ::std::move(from);
  }

  inline Polygen& operator=(Polygen&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Polygen& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Polygen* internal_default_instance() {
    return reinterpret_cast<const Polygen*>(
               &_Polygen_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Polygen* other);
  friend void swap(Polygen& a, Polygen& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Polygen* New() const final {
    return CreateMaybeMessage<Polygen>(NULL);
  }

  Polygen* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Polygen>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Polygen& from);
  void MergeFrom(const Polygen& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polygen* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tros.tros_base.geometry.Point points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  ::tros::tros_base::geometry::Point* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Point >*
      mutable_points();
  const ::tros::tros_base::geometry::Point& points(int index) const;
  ::tros::tros_base::geometry::Point* add_points();
  const ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Point >&
      points() const;

  // @@protoc_insertion_point(class_scope:tros.tros_base.geometry.Polygen)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Point > points_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_base_5fgeometry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Oval : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tros.tros_base.geometry.Oval) */ {
 public:
  Oval();
  virtual ~Oval();

  Oval(const Oval& from);

  inline Oval& operator=(const Oval& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Oval(Oval&& from) noexcept
    : Oval() {
    *this = ::std::move(from);
  }

  inline Oval& operator=(Oval&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Oval& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Oval* internal_default_instance() {
    return reinterpret_cast<const Oval*>(
               &_Oval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Oval* other);
  friend void swap(Oval& a, Oval& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Oval* New() const final {
    return CreateMaybeMessage<Oval>(NULL);
  }

  Oval* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Oval>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Oval& from);
  void MergeFrom(const Oval& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Oval* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float a = 1;
  void clear_a();
  static const int kAFieldNumber = 1;
  float a() const;
  void set_a(float value);

  // float b = 2;
  void clear_b();
  static const int kBFieldNumber = 2;
  float b() const;
  void set_b(float value);

  // @@protoc_insertion_point(class_scope:tros.tros_base.geometry.Oval)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float a_;
  float b_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_base_5fgeometry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Sphere : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tros.tros_base.geometry.Sphere) */ {
 public:
  Sphere();
  virtual ~Sphere();

  Sphere(const Sphere& from);

  inline Sphere& operator=(const Sphere& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sphere(Sphere&& from) noexcept
    : Sphere() {
    *this = ::std::move(from);
  }

  inline Sphere& operator=(Sphere&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Sphere& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sphere* internal_default_instance() {
    return reinterpret_cast<const Sphere*>(
               &_Sphere_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Sphere* other);
  friend void swap(Sphere& a, Sphere& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sphere* New() const final {
    return CreateMaybeMessage<Sphere>(NULL);
  }

  Sphere* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Sphere>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Sphere& from);
  void MergeFrom(const Sphere& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sphere* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float a = 1;
  void clear_a();
  static const int kAFieldNumber = 1;
  float a() const;
  void set_a(float value);

  // float b = 2;
  void clear_b();
  static const int kBFieldNumber = 2;
  float b() const;
  void set_b(float value);

  // float c = 3;
  void clear_c();
  static const int kCFieldNumber = 3;
  float c() const;
  void set_c(float value);

  // @@protoc_insertion_point(class_scope:tros.tros_base.geometry.Sphere)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float a_;
  float b_;
  float c_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_base_5fgeometry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Cone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tros.tros_base.geometry.Cone) */ {
 public:
  Cone();
  virtual ~Cone();

  Cone(const Cone& from);

  inline Cone& operator=(const Cone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Cone(Cone&& from) noexcept
    : Cone() {
    *this = ::std::move(from);
  }

  inline Cone& operator=(Cone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Cone& default_instance();

  enum SurfaceTypeCase {
    kOval = 1,
    kPolygen = 2,
    SURFACE_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Cone* internal_default_instance() {
    return reinterpret_cast<const Cone*>(
               &_Cone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Cone* other);
  friend void swap(Cone& a, Cone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Cone* New() const final {
    return CreateMaybeMessage<Cone>(NULL);
  }

  Cone* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Cone>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Cone& from);
  void MergeFrom(const Cone& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 height = 3;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // .tros.tros_base.geometry.Oval oval = 1;
  bool has_oval() const;
  void clear_oval();
  static const int kOvalFieldNumber = 1;
  private:
  const ::tros::tros_base::geometry::Oval& _internal_oval() const;
  public:
  const ::tros::tros_base::geometry::Oval& oval() const;
  ::tros::tros_base::geometry::Oval* release_oval();
  ::tros::tros_base::geometry::Oval* mutable_oval();
  void set_allocated_oval(::tros::tros_base::geometry::Oval* oval);

  // .tros.tros_base.geometry.Polygen polygen = 2;
  bool has_polygen() const;
  void clear_polygen();
  static const int kPolygenFieldNumber = 2;
  private:
  const ::tros::tros_base::geometry::Polygen& _internal_polygen() const;
  public:
  const ::tros::tros_base::geometry::Polygen& polygen() const;
  ::tros::tros_base::geometry::Polygen* release_polygen();
  ::tros::tros_base::geometry::Polygen* mutable_polygen();
  void set_allocated_polygen(::tros::tros_base::geometry::Polygen* polygen);

  void clear_surface_type();
  SurfaceTypeCase surface_type_case() const;
  // @@protoc_insertion_point(class_scope:tros.tros_base.geometry.Cone)
 private:
  void set_has_oval();
  void set_has_polygen();

  inline bool has_surface_type() const;
  inline void clear_has_surface_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 height_;
  union SurfaceTypeUnion {
    SurfaceTypeUnion() {}
    ::tros::tros_base::geometry::Oval* oval_;
    ::tros::tros_base::geometry::Polygen* polygen_;
  } surface_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_base_5fgeometry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Extrusion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tros.tros_base.geometry.Extrusion) */ {
 public:
  Extrusion();
  virtual ~Extrusion();

  Extrusion(const Extrusion& from);

  inline Extrusion& operator=(const Extrusion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Extrusion(Extrusion&& from) noexcept
    : Extrusion() {
    *this = ::std::move(from);
  }

  inline Extrusion& operator=(Extrusion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Extrusion& default_instance();

  enum SurfaceTypeCase {
    kOval = 1,
    kPolygen = 2,
    SURFACE_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Extrusion* internal_default_instance() {
    return reinterpret_cast<const Extrusion*>(
               &_Extrusion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Extrusion* other);
  friend void swap(Extrusion& a, Extrusion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Extrusion* New() const final {
    return CreateMaybeMessage<Extrusion>(NULL);
  }

  Extrusion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Extrusion>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Extrusion& from);
  void MergeFrom(const Extrusion& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Extrusion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 height = 3;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::uint64 height() const;
  void set_height(::google::protobuf::uint64 value);

  // .tros.tros_base.geometry.Oval oval = 1;
  bool has_oval() const;
  void clear_oval();
  static const int kOvalFieldNumber = 1;
  private:
  const ::tros::tros_base::geometry::Oval& _internal_oval() const;
  public:
  const ::tros::tros_base::geometry::Oval& oval() const;
  ::tros::tros_base::geometry::Oval* release_oval();
  ::tros::tros_base::geometry::Oval* mutable_oval();
  void set_allocated_oval(::tros::tros_base::geometry::Oval* oval);

  // .tros.tros_base.geometry.Polygen polygen = 2;
  bool has_polygen() const;
  void clear_polygen();
  static const int kPolygenFieldNumber = 2;
  private:
  const ::tros::tros_base::geometry::Polygen& _internal_polygen() const;
  public:
  const ::tros::tros_base::geometry::Polygen& polygen() const;
  ::tros::tros_base::geometry::Polygen* release_polygen();
  ::tros::tros_base::geometry::Polygen* mutable_polygen();
  void set_allocated_polygen(::tros::tros_base::geometry::Polygen* polygen);

  void clear_surface_type();
  SurfaceTypeCase surface_type_case() const;
  // @@protoc_insertion_point(class_scope:tros.tros_base.geometry.Extrusion)
 private:
  void set_has_oval();
  void set_has_polygen();

  inline bool has_surface_type() const;
  inline void clear_has_surface_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 height_;
  union SurfaceTypeUnion {
    SurfaceTypeUnion() {}
    ::tros::tros_base::geometry::Oval* oval_;
    ::tros::tros_base::geometry::Polygen* polygen_;
  } surface_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_base_5fgeometry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransformationFrame : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tros.tros_base.geometry.TransformationFrame) */ {
 public:
  TransformationFrame();
  virtual ~TransformationFrame();

  TransformationFrame(const TransformationFrame& from);

  inline TransformationFrame& operator=(const TransformationFrame& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransformationFrame(TransformationFrame&& from) noexcept
    : TransformationFrame() {
    *this = ::std::move(from);
  }

  inline TransformationFrame& operator=(TransformationFrame&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransformationFrame& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransformationFrame* internal_default_instance() {
    return reinterpret_cast<const TransformationFrame*>(
               &_TransformationFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(TransformationFrame* other);
  friend void swap(TransformationFrame& a, TransformationFrame& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransformationFrame* New() const final {
    return CreateMaybeMessage<TransformationFrame>(NULL);
  }

  TransformationFrame* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransformationFrame>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransformationFrame& from);
  void MergeFrom(const TransformationFrame& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransformationFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float tf_to_parent = 4;
  int tf_to_parent_size() const;
  void clear_tf_to_parent();
  static const int kTfToParentFieldNumber = 4;
  float tf_to_parent(int index) const;
  void set_tf_to_parent(int index, float value);
  void add_tf_to_parent(float value);
  const ::google::protobuf::RepeatedField< float >&
      tf_to_parent() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_tf_to_parent();

  // string parent_frame = 2;
  void clear_parent_frame();
  static const int kParentFrameFieldNumber = 2;
  const ::std::string& parent_frame() const;
  void set_parent_frame(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_frame(::std::string&& value);
  #endif
  void set_parent_frame(const char* value);
  void set_parent_frame(const char* value, size_t size);
  ::std::string* mutable_parent_frame();
  ::std::string* release_parent_frame();
  void set_allocated_parent_frame(::std::string* parent_frame);

  // string now_frame = 3;
  void clear_now_frame();
  static const int kNowFrameFieldNumber = 3;
  const ::std::string& now_frame() const;
  void set_now_frame(const ::std::string& value);
  #if LANG_CXX11
  void set_now_frame(::std::string&& value);
  #endif
  void set_now_frame(const char* value);
  void set_now_frame(const char* value, size_t size);
  ::std::string* mutable_now_frame();
  ::std::string* release_now_frame();
  void set_allocated_now_frame(::std::string* now_frame);

  // uint64 time_stamp = 1;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 1;
  ::google::protobuf::uint64 time_stamp() const;
  void set_time_stamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tros.tros_base.geometry.TransformationFrame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > tf_to_parent_;
  mutable int _tf_to_parent_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr parent_frame_;
  ::google::protobuf::internal::ArenaStringPtr now_frame_;
  ::google::protobuf::uint64 time_stamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_base_5fgeometry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Shape : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tros.tros_base.geometry.Shape) */ {
 public:
  Shape();
  virtual ~Shape();

  Shape(const Shape& from);

  inline Shape& operator=(const Shape& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Shape(Shape&& from) noexcept
    : Shape() {
    *this = ::std::move(from);
  }

  inline Shape& operator=(Shape&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Shape& default_instance();

  enum TypeCase {
    kPoint = 1,
    kPointCloud = 2,
    kLine = 3,
    kPolygen = 4,
    kOval = 5,
    kSphere = 6,
    kCone = 7,
    kExtrusion = 8,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Shape* internal_default_instance() {
    return reinterpret_cast<const Shape*>(
               &_Shape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Shape* other);
  friend void swap(Shape& a, Shape& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Shape* New() const final {
    return CreateMaybeMessage<Shape>(NULL);
  }

  Shape* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Shape>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Shape& from);
  void MergeFrom(const Shape& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Shape* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float color_rgb = 10;
  int color_rgb_size() const;
  void clear_color_rgb();
  static const int kColorRgbFieldNumber = 10;
  float color_rgb(int index) const;
  void set_color_rgb(int index, float value);
  void add_color_rgb(float value);
  const ::google::protobuf::RepeatedField< float >&
      color_rgb() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_color_rgb();

  // string name = 12;
  void clear_name();
  static const int kNameFieldNumber = 12;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .tros.tros_base.geometry.TransformationFrame transformation_frame = 11;
  bool has_transformation_frame() const;
  void clear_transformation_frame();
  static const int kTransformationFrameFieldNumber = 11;
  private:
  const ::tros::tros_base::geometry::TransformationFrame& _internal_transformation_frame() const;
  public:
  const ::tros::tros_base::geometry::TransformationFrame& transformation_frame() const;
  ::tros::tros_base::geometry::TransformationFrame* release_transformation_frame();
  ::tros::tros_base::geometry::TransformationFrame* mutable_transformation_frame();
  void set_allocated_transformation_frame(::tros::tros_base::geometry::TransformationFrame* transformation_frame);

  // float apparent = 9;
  void clear_apparent();
  static const int kApparentFieldNumber = 9;
  float apparent() const;
  void set_apparent(float value);

  // .tros.tros_base.geometry.Point point = 1;
  bool has_point() const;
  void clear_point();
  static const int kPointFieldNumber = 1;
  private:
  const ::tros::tros_base::geometry::Point& _internal_point() const;
  public:
  const ::tros::tros_base::geometry::Point& point() const;
  ::tros::tros_base::geometry::Point* release_point();
  ::tros::tros_base::geometry::Point* mutable_point();
  void set_allocated_point(::tros::tros_base::geometry::Point* point);

  // .tros.tros_base.geometry.PointCloud point_cloud = 2;
  bool has_point_cloud() const;
  void clear_point_cloud();
  static const int kPointCloudFieldNumber = 2;
  private:
  const ::tros::tros_base::geometry::PointCloud& _internal_point_cloud() const;
  public:
  const ::tros::tros_base::geometry::PointCloud& point_cloud() const;
  ::tros::tros_base::geometry::PointCloud* release_point_cloud();
  ::tros::tros_base::geometry::PointCloud* mutable_point_cloud();
  void set_allocated_point_cloud(::tros::tros_base::geometry::PointCloud* point_cloud);

  // .tros.tros_base.geometry.Line line = 3;
  bool has_line() const;
  void clear_line();
  static const int kLineFieldNumber = 3;
  private:
  const ::tros::tros_base::geometry::Line& _internal_line() const;
  public:
  const ::tros::tros_base::geometry::Line& line() const;
  ::tros::tros_base::geometry::Line* release_line();
  ::tros::tros_base::geometry::Line* mutable_line();
  void set_allocated_line(::tros::tros_base::geometry::Line* line);

  // .tros.tros_base.geometry.Polygen polygen = 4;
  bool has_polygen() const;
  void clear_polygen();
  static const int kPolygenFieldNumber = 4;
  private:
  const ::tros::tros_base::geometry::Polygen& _internal_polygen() const;
  public:
  const ::tros::tros_base::geometry::Polygen& polygen() const;
  ::tros::tros_base::geometry::Polygen* release_polygen();
  ::tros::tros_base::geometry::Polygen* mutable_polygen();
  void set_allocated_polygen(::tros::tros_base::geometry::Polygen* polygen);

  // .tros.tros_base.geometry.Oval oval = 5;
  bool has_oval() const;
  void clear_oval();
  static const int kOvalFieldNumber = 5;
  private:
  const ::tros::tros_base::geometry::Oval& _internal_oval() const;
  public:
  const ::tros::tros_base::geometry::Oval& oval() const;
  ::tros::tros_base::geometry::Oval* release_oval();
  ::tros::tros_base::geometry::Oval* mutable_oval();
  void set_allocated_oval(::tros::tros_base::geometry::Oval* oval);

  // .tros.tros_base.geometry.Sphere sphere = 6;
  bool has_sphere() const;
  void clear_sphere();
  static const int kSphereFieldNumber = 6;
  private:
  const ::tros::tros_base::geometry::Sphere& _internal_sphere() const;
  public:
  const ::tros::tros_base::geometry::Sphere& sphere() const;
  ::tros::tros_base::geometry::Sphere* release_sphere();
  ::tros::tros_base::geometry::Sphere* mutable_sphere();
  void set_allocated_sphere(::tros::tros_base::geometry::Sphere* sphere);

  // .tros.tros_base.geometry.Cone cone = 7;
  bool has_cone() const;
  void clear_cone();
  static const int kConeFieldNumber = 7;
  private:
  const ::tros::tros_base::geometry::Cone& _internal_cone() const;
  public:
  const ::tros::tros_base::geometry::Cone& cone() const;
  ::tros::tros_base::geometry::Cone* release_cone();
  ::tros::tros_base::geometry::Cone* mutable_cone();
  void set_allocated_cone(::tros::tros_base::geometry::Cone* cone);

  // .tros.tros_base.geometry.Extrusion extrusion = 8;
  bool has_extrusion() const;
  void clear_extrusion();
  static const int kExtrusionFieldNumber = 8;
  private:
  const ::tros::tros_base::geometry::Extrusion& _internal_extrusion() const;
  public:
  const ::tros::tros_base::geometry::Extrusion& extrusion() const;
  ::tros::tros_base::geometry::Extrusion* release_extrusion();
  ::tros::tros_base::geometry::Extrusion* mutable_extrusion();
  void set_allocated_extrusion(::tros::tros_base::geometry::Extrusion* extrusion);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:tros.tros_base.geometry.Shape)
 private:
  void set_has_point();
  void set_has_point_cloud();
  void set_has_line();
  void set_has_polygen();
  void set_has_oval();
  void set_has_sphere();
  void set_has_cone();
  void set_has_extrusion();

  inline bool has_type() const;
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > color_rgb_;
  mutable int _color_rgb_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::tros::tros_base::geometry::TransformationFrame* transformation_frame_;
  float apparent_;
  union TypeUnion {
    TypeUnion() {}
    ::tros::tros_base::geometry::Point* point_;
    ::tros::tros_base::geometry::PointCloud* point_cloud_;
    ::tros::tros_base::geometry::Line* line_;
    ::tros::tros_base::geometry::Polygen* polygen_;
    ::tros::tros_base::geometry::Oval* oval_;
    ::tros::tros_base::geometry::Sphere* sphere_;
    ::tros::tros_base::geometry::Cone* cone_;
    ::tros::tros_base::geometry::Extrusion* extrusion_;
  } type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_base_5fgeometry_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scene : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tros.tros_base.geometry.Scene) */ {
 public:
  Scene();
  virtual ~Scene();

  Scene(const Scene& from);

  inline Scene& operator=(const Scene& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scene(Scene&& from) noexcept
    : Scene() {
    *this = ::std::move(from);
  }

  inline Scene& operator=(Scene&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Scene& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scene* internal_default_instance() {
    return reinterpret_cast<const Scene*>(
               &_Scene_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Scene* other);
  friend void swap(Scene& a, Scene& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scene* New() const final {
    return CreateMaybeMessage<Scene>(NULL);
  }

  Scene* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Scene>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Scene& from);
  void MergeFrom(const Scene& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scene* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tros.tros_base.geometry.Shape shapes = 2;
  int shapes_size() const;
  void clear_shapes();
  static const int kShapesFieldNumber = 2;
  ::tros::tros_base::geometry::Shape* mutable_shapes(int index);
  ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Shape >*
      mutable_shapes();
  const ::tros::tros_base::geometry::Shape& shapes(int index) const;
  ::tros::tros_base::geometry::Shape* add_shapes();
  const ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Shape >&
      shapes() const;

  // .tros.tros_base.common.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::tros::tros_base::common::Header& _internal_header() const;
  public:
  const ::tros::tros_base::common::Header& header() const;
  ::tros::tros_base::common::Header* release_header();
  ::tros::tros_base::common::Header* mutable_header();
  void set_allocated_header(::tros::tros_base::common::Header* header);

  // @@protoc_insertion_point(class_scope:tros.tros_base.geometry.Scene)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Shape > shapes_;
  ::tros::tros_base::common::Header* header_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_base_5fgeometry_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point

// repeated float data = 1;
inline int Point::data_size() const {
  return data_.size();
}
inline void Point::clear_data() {
  data_.Clear();
}
inline float Point::data(int index) const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Point.data)
  return data_.Get(index);
}
inline void Point::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:tros.tros_base.geometry.Point.data)
}
inline void Point::add_data(float value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:tros.tros_base.geometry.Point.data)
}
inline const ::google::protobuf::RepeatedField< float >&
Point::data() const {
  // @@protoc_insertion_point(field_list:tros.tros_base.geometry.Point.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
Point::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:tros.tros_base.geometry.Point.data)
  return &data_;
}

// float width = 2;
inline void Point::clear_width() {
  width_ = 0;
}
inline float Point::width() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Point.width)
  return width_;
}
inline void Point::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:tros.tros_base.geometry.Point.width)
}

// -------------------------------------------------------------------

// PointCloud

// repeated .tros.tros_base.geometry.Point points = 1;
inline int PointCloud::points_size() const {
  return points_.size();
}
inline void PointCloud::clear_points() {
  points_.Clear();
}
inline ::tros::tros_base::geometry::Point* PointCloud::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.PointCloud.points)
  return points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Point >*
PointCloud::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:tros.tros_base.geometry.PointCloud.points)
  return &points_;
}
inline const ::tros::tros_base::geometry::Point& PointCloud::points(int index) const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.PointCloud.points)
  return points_.Get(index);
}
inline ::tros::tros_base::geometry::Point* PointCloud::add_points() {
  // @@protoc_insertion_point(field_add:tros.tros_base.geometry.PointCloud.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Point >&
PointCloud::points() const {
  // @@protoc_insertion_point(field_list:tros.tros_base.geometry.PointCloud.points)
  return points_;
}

// -------------------------------------------------------------------

// Line

// repeated .tros.tros_base.geometry.Point points = 1;
inline int Line::points_size() const {
  return points_.size();
}
inline void Line::clear_points() {
  points_.Clear();
}
inline ::tros::tros_base::geometry::Point* Line::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Line.points)
  return points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Point >*
Line::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:tros.tros_base.geometry.Line.points)
  return &points_;
}
inline const ::tros::tros_base::geometry::Point& Line::points(int index) const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Line.points)
  return points_.Get(index);
}
inline ::tros::tros_base::geometry::Point* Line::add_points() {
  // @@protoc_insertion_point(field_add:tros.tros_base.geometry.Line.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Point >&
Line::points() const {
  // @@protoc_insertion_point(field_list:tros.tros_base.geometry.Line.points)
  return points_;
}

// float width = 2;
inline void Line::clear_width() {
  width_ = 0;
}
inline float Line::width() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Line.width)
  return width_;
}
inline void Line::set_width(float value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:tros.tros_base.geometry.Line.width)
}

// -------------------------------------------------------------------

// Polygen

// repeated .tros.tros_base.geometry.Point points = 1;
inline int Polygen::points_size() const {
  return points_.size();
}
inline void Polygen::clear_points() {
  points_.Clear();
}
inline ::tros::tros_base::geometry::Point* Polygen::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Polygen.points)
  return points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Point >*
Polygen::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:tros.tros_base.geometry.Polygen.points)
  return &points_;
}
inline const ::tros::tros_base::geometry::Point& Polygen::points(int index) const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Polygen.points)
  return points_.Get(index);
}
inline ::tros::tros_base::geometry::Point* Polygen::add_points() {
  // @@protoc_insertion_point(field_add:tros.tros_base.geometry.Polygen.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Point >&
Polygen::points() const {
  // @@protoc_insertion_point(field_list:tros.tros_base.geometry.Polygen.points)
  return points_;
}

// -------------------------------------------------------------------

// Oval

// float a = 1;
inline void Oval::clear_a() {
  a_ = 0;
}
inline float Oval::a() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Oval.a)
  return a_;
}
inline void Oval::set_a(float value) {
  
  a_ = value;
  // @@protoc_insertion_point(field_set:tros.tros_base.geometry.Oval.a)
}

// float b = 2;
inline void Oval::clear_b() {
  b_ = 0;
}
inline float Oval::b() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Oval.b)
  return b_;
}
inline void Oval::set_b(float value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:tros.tros_base.geometry.Oval.b)
}

// -------------------------------------------------------------------

// Sphere

// float a = 1;
inline void Sphere::clear_a() {
  a_ = 0;
}
inline float Sphere::a() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Sphere.a)
  return a_;
}
inline void Sphere::set_a(float value) {
  
  a_ = value;
  // @@protoc_insertion_point(field_set:tros.tros_base.geometry.Sphere.a)
}

// float b = 2;
inline void Sphere::clear_b() {
  b_ = 0;
}
inline float Sphere::b() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Sphere.b)
  return b_;
}
inline void Sphere::set_b(float value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:tros.tros_base.geometry.Sphere.b)
}

// float c = 3;
inline void Sphere::clear_c() {
  c_ = 0;
}
inline float Sphere::c() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Sphere.c)
  return c_;
}
inline void Sphere::set_c(float value) {
  
  c_ = value;
  // @@protoc_insertion_point(field_set:tros.tros_base.geometry.Sphere.c)
}

// -------------------------------------------------------------------

// Cone

// .tros.tros_base.geometry.Oval oval = 1;
inline bool Cone::has_oval() const {
  return surface_type_case() == kOval;
}
inline void Cone::set_has_oval() {
  _oneof_case_[0] = kOval;
}
inline void Cone::clear_oval() {
  if (has_oval()) {
    delete surface_type_.oval_;
    clear_has_surface_type();
  }
}
inline const ::tros::tros_base::geometry::Oval& Cone::_internal_oval() const {
  return *surface_type_.oval_;
}
inline ::tros::tros_base::geometry::Oval* Cone::release_oval() {
  // @@protoc_insertion_point(field_release:tros.tros_base.geometry.Cone.oval)
  if (has_oval()) {
    clear_has_surface_type();
      ::tros::tros_base::geometry::Oval* temp = surface_type_.oval_;
    surface_type_.oval_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tros::tros_base::geometry::Oval& Cone::oval() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Cone.oval)
  return has_oval()
      ? *surface_type_.oval_
      : *reinterpret_cast< ::tros::tros_base::geometry::Oval*>(&::tros::tros_base::geometry::_Oval_default_instance_);
}
inline ::tros::tros_base::geometry::Oval* Cone::mutable_oval() {
  if (!has_oval()) {
    clear_surface_type();
    set_has_oval();
    surface_type_.oval_ = CreateMaybeMessage< ::tros::tros_base::geometry::Oval >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Cone.oval)
  return surface_type_.oval_;
}

// .tros.tros_base.geometry.Polygen polygen = 2;
inline bool Cone::has_polygen() const {
  return surface_type_case() == kPolygen;
}
inline void Cone::set_has_polygen() {
  _oneof_case_[0] = kPolygen;
}
inline void Cone::clear_polygen() {
  if (has_polygen()) {
    delete surface_type_.polygen_;
    clear_has_surface_type();
  }
}
inline const ::tros::tros_base::geometry::Polygen& Cone::_internal_polygen() const {
  return *surface_type_.polygen_;
}
inline ::tros::tros_base::geometry::Polygen* Cone::release_polygen() {
  // @@protoc_insertion_point(field_release:tros.tros_base.geometry.Cone.polygen)
  if (has_polygen()) {
    clear_has_surface_type();
      ::tros::tros_base::geometry::Polygen* temp = surface_type_.polygen_;
    surface_type_.polygen_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tros::tros_base::geometry::Polygen& Cone::polygen() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Cone.polygen)
  return has_polygen()
      ? *surface_type_.polygen_
      : *reinterpret_cast< ::tros::tros_base::geometry::Polygen*>(&::tros::tros_base::geometry::_Polygen_default_instance_);
}
inline ::tros::tros_base::geometry::Polygen* Cone::mutable_polygen() {
  if (!has_polygen()) {
    clear_surface_type();
    set_has_polygen();
    surface_type_.polygen_ = CreateMaybeMessage< ::tros::tros_base::geometry::Polygen >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Cone.polygen)
  return surface_type_.polygen_;
}

// uint64 height = 3;
inline void Cone::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Cone::height() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Cone.height)
  return height_;
}
inline void Cone::set_height(::google::protobuf::uint64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:tros.tros_base.geometry.Cone.height)
}

inline bool Cone::has_surface_type() const {
  return surface_type_case() != SURFACE_TYPE_NOT_SET;
}
inline void Cone::clear_has_surface_type() {
  _oneof_case_[0] = SURFACE_TYPE_NOT_SET;
}
inline Cone::SurfaceTypeCase Cone::surface_type_case() const {
  return Cone::SurfaceTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Extrusion

// .tros.tros_base.geometry.Oval oval = 1;
inline bool Extrusion::has_oval() const {
  return surface_type_case() == kOval;
}
inline void Extrusion::set_has_oval() {
  _oneof_case_[0] = kOval;
}
inline void Extrusion::clear_oval() {
  if (has_oval()) {
    delete surface_type_.oval_;
    clear_has_surface_type();
  }
}
inline const ::tros::tros_base::geometry::Oval& Extrusion::_internal_oval() const {
  return *surface_type_.oval_;
}
inline ::tros::tros_base::geometry::Oval* Extrusion::release_oval() {
  // @@protoc_insertion_point(field_release:tros.tros_base.geometry.Extrusion.oval)
  if (has_oval()) {
    clear_has_surface_type();
      ::tros::tros_base::geometry::Oval* temp = surface_type_.oval_;
    surface_type_.oval_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tros::tros_base::geometry::Oval& Extrusion::oval() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Extrusion.oval)
  return has_oval()
      ? *surface_type_.oval_
      : *reinterpret_cast< ::tros::tros_base::geometry::Oval*>(&::tros::tros_base::geometry::_Oval_default_instance_);
}
inline ::tros::tros_base::geometry::Oval* Extrusion::mutable_oval() {
  if (!has_oval()) {
    clear_surface_type();
    set_has_oval();
    surface_type_.oval_ = CreateMaybeMessage< ::tros::tros_base::geometry::Oval >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Extrusion.oval)
  return surface_type_.oval_;
}

// .tros.tros_base.geometry.Polygen polygen = 2;
inline bool Extrusion::has_polygen() const {
  return surface_type_case() == kPolygen;
}
inline void Extrusion::set_has_polygen() {
  _oneof_case_[0] = kPolygen;
}
inline void Extrusion::clear_polygen() {
  if (has_polygen()) {
    delete surface_type_.polygen_;
    clear_has_surface_type();
  }
}
inline const ::tros::tros_base::geometry::Polygen& Extrusion::_internal_polygen() const {
  return *surface_type_.polygen_;
}
inline ::tros::tros_base::geometry::Polygen* Extrusion::release_polygen() {
  // @@protoc_insertion_point(field_release:tros.tros_base.geometry.Extrusion.polygen)
  if (has_polygen()) {
    clear_has_surface_type();
      ::tros::tros_base::geometry::Polygen* temp = surface_type_.polygen_;
    surface_type_.polygen_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tros::tros_base::geometry::Polygen& Extrusion::polygen() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Extrusion.polygen)
  return has_polygen()
      ? *surface_type_.polygen_
      : *reinterpret_cast< ::tros::tros_base::geometry::Polygen*>(&::tros::tros_base::geometry::_Polygen_default_instance_);
}
inline ::tros::tros_base::geometry::Polygen* Extrusion::mutable_polygen() {
  if (!has_polygen()) {
    clear_surface_type();
    set_has_polygen();
    surface_type_.polygen_ = CreateMaybeMessage< ::tros::tros_base::geometry::Polygen >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Extrusion.polygen)
  return surface_type_.polygen_;
}

// uint64 height = 3;
inline void Extrusion::clear_height() {
  height_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Extrusion::height() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Extrusion.height)
  return height_;
}
inline void Extrusion::set_height(::google::protobuf::uint64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:tros.tros_base.geometry.Extrusion.height)
}

inline bool Extrusion::has_surface_type() const {
  return surface_type_case() != SURFACE_TYPE_NOT_SET;
}
inline void Extrusion::clear_has_surface_type() {
  _oneof_case_[0] = SURFACE_TYPE_NOT_SET;
}
inline Extrusion::SurfaceTypeCase Extrusion::surface_type_case() const {
  return Extrusion::SurfaceTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TransformationFrame

// uint64 time_stamp = 1;
inline void TransformationFrame::clear_time_stamp() {
  time_stamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TransformationFrame::time_stamp() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.TransformationFrame.time_stamp)
  return time_stamp_;
}
inline void TransformationFrame::set_time_stamp(::google::protobuf::uint64 value) {
  
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:tros.tros_base.geometry.TransformationFrame.time_stamp)
}

// string parent_frame = 2;
inline void TransformationFrame::clear_parent_frame() {
  parent_frame_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransformationFrame::parent_frame() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.TransformationFrame.parent_frame)
  return parent_frame_.GetNoArena();
}
inline void TransformationFrame::set_parent_frame(const ::std::string& value) {
  
  parent_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tros.tros_base.geometry.TransformationFrame.parent_frame)
}
#if LANG_CXX11
inline void TransformationFrame::set_parent_frame(::std::string&& value) {
  
  parent_frame_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tros.tros_base.geometry.TransformationFrame.parent_frame)
}
#endif
inline void TransformationFrame::set_parent_frame(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  parent_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tros.tros_base.geometry.TransformationFrame.parent_frame)
}
inline void TransformationFrame::set_parent_frame(const char* value, size_t size) {
  
  parent_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tros.tros_base.geometry.TransformationFrame.parent_frame)
}
inline ::std::string* TransformationFrame::mutable_parent_frame() {
  
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.TransformationFrame.parent_frame)
  return parent_frame_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransformationFrame::release_parent_frame() {
  // @@protoc_insertion_point(field_release:tros.tros_base.geometry.TransformationFrame.parent_frame)
  
  return parent_frame_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransformationFrame::set_allocated_parent_frame(::std::string* parent_frame) {
  if (parent_frame != NULL) {
    
  } else {
    
  }
  parent_frame_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_frame);
  // @@protoc_insertion_point(field_set_allocated:tros.tros_base.geometry.TransformationFrame.parent_frame)
}

// string now_frame = 3;
inline void TransformationFrame::clear_now_frame() {
  now_frame_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransformationFrame::now_frame() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.TransformationFrame.now_frame)
  return now_frame_.GetNoArena();
}
inline void TransformationFrame::set_now_frame(const ::std::string& value) {
  
  now_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tros.tros_base.geometry.TransformationFrame.now_frame)
}
#if LANG_CXX11
inline void TransformationFrame::set_now_frame(::std::string&& value) {
  
  now_frame_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tros.tros_base.geometry.TransformationFrame.now_frame)
}
#endif
inline void TransformationFrame::set_now_frame(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  now_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tros.tros_base.geometry.TransformationFrame.now_frame)
}
inline void TransformationFrame::set_now_frame(const char* value, size_t size) {
  
  now_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tros.tros_base.geometry.TransformationFrame.now_frame)
}
inline ::std::string* TransformationFrame::mutable_now_frame() {
  
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.TransformationFrame.now_frame)
  return now_frame_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransformationFrame::release_now_frame() {
  // @@protoc_insertion_point(field_release:tros.tros_base.geometry.TransformationFrame.now_frame)
  
  return now_frame_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransformationFrame::set_allocated_now_frame(::std::string* now_frame) {
  if (now_frame != NULL) {
    
  } else {
    
  }
  now_frame_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), now_frame);
  // @@protoc_insertion_point(field_set_allocated:tros.tros_base.geometry.TransformationFrame.now_frame)
}

// repeated float tf_to_parent = 4;
inline int TransformationFrame::tf_to_parent_size() const {
  return tf_to_parent_.size();
}
inline void TransformationFrame::clear_tf_to_parent() {
  tf_to_parent_.Clear();
}
inline float TransformationFrame::tf_to_parent(int index) const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.TransformationFrame.tf_to_parent)
  return tf_to_parent_.Get(index);
}
inline void TransformationFrame::set_tf_to_parent(int index, float value) {
  tf_to_parent_.Set(index, value);
  // @@protoc_insertion_point(field_set:tros.tros_base.geometry.TransformationFrame.tf_to_parent)
}
inline void TransformationFrame::add_tf_to_parent(float value) {
  tf_to_parent_.Add(value);
  // @@protoc_insertion_point(field_add:tros.tros_base.geometry.TransformationFrame.tf_to_parent)
}
inline const ::google::protobuf::RepeatedField< float >&
TransformationFrame::tf_to_parent() const {
  // @@protoc_insertion_point(field_list:tros.tros_base.geometry.TransformationFrame.tf_to_parent)
  return tf_to_parent_;
}
inline ::google::protobuf::RepeatedField< float >*
TransformationFrame::mutable_tf_to_parent() {
  // @@protoc_insertion_point(field_mutable_list:tros.tros_base.geometry.TransformationFrame.tf_to_parent)
  return &tf_to_parent_;
}

// -------------------------------------------------------------------

// Shape

// .tros.tros_base.geometry.Point point = 1;
inline bool Shape::has_point() const {
  return type_case() == kPoint;
}
inline void Shape::set_has_point() {
  _oneof_case_[0] = kPoint;
}
inline void Shape::clear_point() {
  if (has_point()) {
    delete type_.point_;
    clear_has_type();
  }
}
inline const ::tros::tros_base::geometry::Point& Shape::_internal_point() const {
  return *type_.point_;
}
inline ::tros::tros_base::geometry::Point* Shape::release_point() {
  // @@protoc_insertion_point(field_release:tros.tros_base.geometry.Shape.point)
  if (has_point()) {
    clear_has_type();
      ::tros::tros_base::geometry::Point* temp = type_.point_;
    type_.point_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tros::tros_base::geometry::Point& Shape::point() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Shape.point)
  return has_point()
      ? *type_.point_
      : *reinterpret_cast< ::tros::tros_base::geometry::Point*>(&::tros::tros_base::geometry::_Point_default_instance_);
}
inline ::tros::tros_base::geometry::Point* Shape::mutable_point() {
  if (!has_point()) {
    clear_type();
    set_has_point();
    type_.point_ = CreateMaybeMessage< ::tros::tros_base::geometry::Point >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Shape.point)
  return type_.point_;
}

// .tros.tros_base.geometry.PointCloud point_cloud = 2;
inline bool Shape::has_point_cloud() const {
  return type_case() == kPointCloud;
}
inline void Shape::set_has_point_cloud() {
  _oneof_case_[0] = kPointCloud;
}
inline void Shape::clear_point_cloud() {
  if (has_point_cloud()) {
    delete type_.point_cloud_;
    clear_has_type();
  }
}
inline const ::tros::tros_base::geometry::PointCloud& Shape::_internal_point_cloud() const {
  return *type_.point_cloud_;
}
inline ::tros::tros_base::geometry::PointCloud* Shape::release_point_cloud() {
  // @@protoc_insertion_point(field_release:tros.tros_base.geometry.Shape.point_cloud)
  if (has_point_cloud()) {
    clear_has_type();
      ::tros::tros_base::geometry::PointCloud* temp = type_.point_cloud_;
    type_.point_cloud_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tros::tros_base::geometry::PointCloud& Shape::point_cloud() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Shape.point_cloud)
  return has_point_cloud()
      ? *type_.point_cloud_
      : *reinterpret_cast< ::tros::tros_base::geometry::PointCloud*>(&::tros::tros_base::geometry::_PointCloud_default_instance_);
}
inline ::tros::tros_base::geometry::PointCloud* Shape::mutable_point_cloud() {
  if (!has_point_cloud()) {
    clear_type();
    set_has_point_cloud();
    type_.point_cloud_ = CreateMaybeMessage< ::tros::tros_base::geometry::PointCloud >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Shape.point_cloud)
  return type_.point_cloud_;
}

// .tros.tros_base.geometry.Line line = 3;
inline bool Shape::has_line() const {
  return type_case() == kLine;
}
inline void Shape::set_has_line() {
  _oneof_case_[0] = kLine;
}
inline void Shape::clear_line() {
  if (has_line()) {
    delete type_.line_;
    clear_has_type();
  }
}
inline const ::tros::tros_base::geometry::Line& Shape::_internal_line() const {
  return *type_.line_;
}
inline ::tros::tros_base::geometry::Line* Shape::release_line() {
  // @@protoc_insertion_point(field_release:tros.tros_base.geometry.Shape.line)
  if (has_line()) {
    clear_has_type();
      ::tros::tros_base::geometry::Line* temp = type_.line_;
    type_.line_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tros::tros_base::geometry::Line& Shape::line() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Shape.line)
  return has_line()
      ? *type_.line_
      : *reinterpret_cast< ::tros::tros_base::geometry::Line*>(&::tros::tros_base::geometry::_Line_default_instance_);
}
inline ::tros::tros_base::geometry::Line* Shape::mutable_line() {
  if (!has_line()) {
    clear_type();
    set_has_line();
    type_.line_ = CreateMaybeMessage< ::tros::tros_base::geometry::Line >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Shape.line)
  return type_.line_;
}

// .tros.tros_base.geometry.Polygen polygen = 4;
inline bool Shape::has_polygen() const {
  return type_case() == kPolygen;
}
inline void Shape::set_has_polygen() {
  _oneof_case_[0] = kPolygen;
}
inline void Shape::clear_polygen() {
  if (has_polygen()) {
    delete type_.polygen_;
    clear_has_type();
  }
}
inline const ::tros::tros_base::geometry::Polygen& Shape::_internal_polygen() const {
  return *type_.polygen_;
}
inline ::tros::tros_base::geometry::Polygen* Shape::release_polygen() {
  // @@protoc_insertion_point(field_release:tros.tros_base.geometry.Shape.polygen)
  if (has_polygen()) {
    clear_has_type();
      ::tros::tros_base::geometry::Polygen* temp = type_.polygen_;
    type_.polygen_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tros::tros_base::geometry::Polygen& Shape::polygen() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Shape.polygen)
  return has_polygen()
      ? *type_.polygen_
      : *reinterpret_cast< ::tros::tros_base::geometry::Polygen*>(&::tros::tros_base::geometry::_Polygen_default_instance_);
}
inline ::tros::tros_base::geometry::Polygen* Shape::mutable_polygen() {
  if (!has_polygen()) {
    clear_type();
    set_has_polygen();
    type_.polygen_ = CreateMaybeMessage< ::tros::tros_base::geometry::Polygen >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Shape.polygen)
  return type_.polygen_;
}

// .tros.tros_base.geometry.Oval oval = 5;
inline bool Shape::has_oval() const {
  return type_case() == kOval;
}
inline void Shape::set_has_oval() {
  _oneof_case_[0] = kOval;
}
inline void Shape::clear_oval() {
  if (has_oval()) {
    delete type_.oval_;
    clear_has_type();
  }
}
inline const ::tros::tros_base::geometry::Oval& Shape::_internal_oval() const {
  return *type_.oval_;
}
inline ::tros::tros_base::geometry::Oval* Shape::release_oval() {
  // @@protoc_insertion_point(field_release:tros.tros_base.geometry.Shape.oval)
  if (has_oval()) {
    clear_has_type();
      ::tros::tros_base::geometry::Oval* temp = type_.oval_;
    type_.oval_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tros::tros_base::geometry::Oval& Shape::oval() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Shape.oval)
  return has_oval()
      ? *type_.oval_
      : *reinterpret_cast< ::tros::tros_base::geometry::Oval*>(&::tros::tros_base::geometry::_Oval_default_instance_);
}
inline ::tros::tros_base::geometry::Oval* Shape::mutable_oval() {
  if (!has_oval()) {
    clear_type();
    set_has_oval();
    type_.oval_ = CreateMaybeMessage< ::tros::tros_base::geometry::Oval >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Shape.oval)
  return type_.oval_;
}

// .tros.tros_base.geometry.Sphere sphere = 6;
inline bool Shape::has_sphere() const {
  return type_case() == kSphere;
}
inline void Shape::set_has_sphere() {
  _oneof_case_[0] = kSphere;
}
inline void Shape::clear_sphere() {
  if (has_sphere()) {
    delete type_.sphere_;
    clear_has_type();
  }
}
inline const ::tros::tros_base::geometry::Sphere& Shape::_internal_sphere() const {
  return *type_.sphere_;
}
inline ::tros::tros_base::geometry::Sphere* Shape::release_sphere() {
  // @@protoc_insertion_point(field_release:tros.tros_base.geometry.Shape.sphere)
  if (has_sphere()) {
    clear_has_type();
      ::tros::tros_base::geometry::Sphere* temp = type_.sphere_;
    type_.sphere_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tros::tros_base::geometry::Sphere& Shape::sphere() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Shape.sphere)
  return has_sphere()
      ? *type_.sphere_
      : *reinterpret_cast< ::tros::tros_base::geometry::Sphere*>(&::tros::tros_base::geometry::_Sphere_default_instance_);
}
inline ::tros::tros_base::geometry::Sphere* Shape::mutable_sphere() {
  if (!has_sphere()) {
    clear_type();
    set_has_sphere();
    type_.sphere_ = CreateMaybeMessage< ::tros::tros_base::geometry::Sphere >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Shape.sphere)
  return type_.sphere_;
}

// .tros.tros_base.geometry.Cone cone = 7;
inline bool Shape::has_cone() const {
  return type_case() == kCone;
}
inline void Shape::set_has_cone() {
  _oneof_case_[0] = kCone;
}
inline void Shape::clear_cone() {
  if (has_cone()) {
    delete type_.cone_;
    clear_has_type();
  }
}
inline const ::tros::tros_base::geometry::Cone& Shape::_internal_cone() const {
  return *type_.cone_;
}
inline ::tros::tros_base::geometry::Cone* Shape::release_cone() {
  // @@protoc_insertion_point(field_release:tros.tros_base.geometry.Shape.cone)
  if (has_cone()) {
    clear_has_type();
      ::tros::tros_base::geometry::Cone* temp = type_.cone_;
    type_.cone_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tros::tros_base::geometry::Cone& Shape::cone() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Shape.cone)
  return has_cone()
      ? *type_.cone_
      : *reinterpret_cast< ::tros::tros_base::geometry::Cone*>(&::tros::tros_base::geometry::_Cone_default_instance_);
}
inline ::tros::tros_base::geometry::Cone* Shape::mutable_cone() {
  if (!has_cone()) {
    clear_type();
    set_has_cone();
    type_.cone_ = CreateMaybeMessage< ::tros::tros_base::geometry::Cone >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Shape.cone)
  return type_.cone_;
}

// .tros.tros_base.geometry.Extrusion extrusion = 8;
inline bool Shape::has_extrusion() const {
  return type_case() == kExtrusion;
}
inline void Shape::set_has_extrusion() {
  _oneof_case_[0] = kExtrusion;
}
inline void Shape::clear_extrusion() {
  if (has_extrusion()) {
    delete type_.extrusion_;
    clear_has_type();
  }
}
inline const ::tros::tros_base::geometry::Extrusion& Shape::_internal_extrusion() const {
  return *type_.extrusion_;
}
inline ::tros::tros_base::geometry::Extrusion* Shape::release_extrusion() {
  // @@protoc_insertion_point(field_release:tros.tros_base.geometry.Shape.extrusion)
  if (has_extrusion()) {
    clear_has_type();
      ::tros::tros_base::geometry::Extrusion* temp = type_.extrusion_;
    type_.extrusion_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tros::tros_base::geometry::Extrusion& Shape::extrusion() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Shape.extrusion)
  return has_extrusion()
      ? *type_.extrusion_
      : *reinterpret_cast< ::tros::tros_base::geometry::Extrusion*>(&::tros::tros_base::geometry::_Extrusion_default_instance_);
}
inline ::tros::tros_base::geometry::Extrusion* Shape::mutable_extrusion() {
  if (!has_extrusion()) {
    clear_type();
    set_has_extrusion();
    type_.extrusion_ = CreateMaybeMessage< ::tros::tros_base::geometry::Extrusion >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Shape.extrusion)
  return type_.extrusion_;
}

// float apparent = 9;
inline void Shape::clear_apparent() {
  apparent_ = 0;
}
inline float Shape::apparent() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Shape.apparent)
  return apparent_;
}
inline void Shape::set_apparent(float value) {
  
  apparent_ = value;
  // @@protoc_insertion_point(field_set:tros.tros_base.geometry.Shape.apparent)
}

// repeated float color_rgb = 10;
inline int Shape::color_rgb_size() const {
  return color_rgb_.size();
}
inline void Shape::clear_color_rgb() {
  color_rgb_.Clear();
}
inline float Shape::color_rgb(int index) const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Shape.color_rgb)
  return color_rgb_.Get(index);
}
inline void Shape::set_color_rgb(int index, float value) {
  color_rgb_.Set(index, value);
  // @@protoc_insertion_point(field_set:tros.tros_base.geometry.Shape.color_rgb)
}
inline void Shape::add_color_rgb(float value) {
  color_rgb_.Add(value);
  // @@protoc_insertion_point(field_add:tros.tros_base.geometry.Shape.color_rgb)
}
inline const ::google::protobuf::RepeatedField< float >&
Shape::color_rgb() const {
  // @@protoc_insertion_point(field_list:tros.tros_base.geometry.Shape.color_rgb)
  return color_rgb_;
}
inline ::google::protobuf::RepeatedField< float >*
Shape::mutable_color_rgb() {
  // @@protoc_insertion_point(field_mutable_list:tros.tros_base.geometry.Shape.color_rgb)
  return &color_rgb_;
}

// .tros.tros_base.geometry.TransformationFrame transformation_frame = 11;
inline bool Shape::has_transformation_frame() const {
  return this != internal_default_instance() && transformation_frame_ != NULL;
}
inline void Shape::clear_transformation_frame() {
  if (GetArenaNoVirtual() == NULL && transformation_frame_ != NULL) {
    delete transformation_frame_;
  }
  transformation_frame_ = NULL;
}
inline const ::tros::tros_base::geometry::TransformationFrame& Shape::_internal_transformation_frame() const {
  return *transformation_frame_;
}
inline const ::tros::tros_base::geometry::TransformationFrame& Shape::transformation_frame() const {
  const ::tros::tros_base::geometry::TransformationFrame* p = transformation_frame_;
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Shape.transformation_frame)
  return p != NULL ? *p : *reinterpret_cast<const ::tros::tros_base::geometry::TransformationFrame*>(
      &::tros::tros_base::geometry::_TransformationFrame_default_instance_);
}
inline ::tros::tros_base::geometry::TransformationFrame* Shape::release_transformation_frame() {
  // @@protoc_insertion_point(field_release:tros.tros_base.geometry.Shape.transformation_frame)
  
  ::tros::tros_base::geometry::TransformationFrame* temp = transformation_frame_;
  transformation_frame_ = NULL;
  return temp;
}
inline ::tros::tros_base::geometry::TransformationFrame* Shape::mutable_transformation_frame() {
  
  if (transformation_frame_ == NULL) {
    auto* p = CreateMaybeMessage<::tros::tros_base::geometry::TransformationFrame>(GetArenaNoVirtual());
    transformation_frame_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Shape.transformation_frame)
  return transformation_frame_;
}
inline void Shape::set_allocated_transformation_frame(::tros::tros_base::geometry::TransformationFrame* transformation_frame) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transformation_frame_;
  }
  if (transformation_frame) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transformation_frame = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transformation_frame, submessage_arena);
    }
    
  } else {
    
  }
  transformation_frame_ = transformation_frame;
  // @@protoc_insertion_point(field_set_allocated:tros.tros_base.geometry.Shape.transformation_frame)
}

// string name = 12;
inline void Shape::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Shape::name() const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Shape.name)
  return name_.GetNoArena();
}
inline void Shape::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tros.tros_base.geometry.Shape.name)
}
#if LANG_CXX11
inline void Shape::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tros.tros_base.geometry.Shape.name)
}
#endif
inline void Shape::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tros.tros_base.geometry.Shape.name)
}
inline void Shape::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tros.tros_base.geometry.Shape.name)
}
inline ::std::string* Shape::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Shape.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Shape::release_name() {
  // @@protoc_insertion_point(field_release:tros.tros_base.geometry.Shape.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Shape::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tros.tros_base.geometry.Shape.name)
}

inline bool Shape::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Shape::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Shape::TypeCase Shape::type_case() const {
  return Shape::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Scene

// .tros.tros_base.common.Header header = 1;
inline bool Scene::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline const ::tros::tros_base::common::Header& Scene::_internal_header() const {
  return *header_;
}
inline const ::tros::tros_base::common::Header& Scene::header() const {
  const ::tros::tros_base::common::Header* p = header_;
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Scene.header)
  return p != NULL ? *p : *reinterpret_cast<const ::tros::tros_base::common::Header*>(
      &::tros::tros_base::common::_Header_default_instance_);
}
inline ::tros::tros_base::common::Header* Scene::release_header() {
  // @@protoc_insertion_point(field_release:tros.tros_base.geometry.Scene.header)
  
  ::tros::tros_base::common::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::tros::tros_base::common::Header* Scene::mutable_header() {
  
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::tros::tros_base::common::Header>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Scene.header)
  return header_;
}
inline void Scene::set_allocated_header(::tros::tros_base::common::Header* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(header_);
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:tros.tros_base.geometry.Scene.header)
}

// repeated .tros.tros_base.geometry.Shape shapes = 2;
inline int Scene::shapes_size() const {
  return shapes_.size();
}
inline void Scene::clear_shapes() {
  shapes_.Clear();
}
inline ::tros::tros_base::geometry::Shape* Scene::mutable_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:tros.tros_base.geometry.Scene.shapes)
  return shapes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Shape >*
Scene::mutable_shapes() {
  // @@protoc_insertion_point(field_mutable_list:tros.tros_base.geometry.Scene.shapes)
  return &shapes_;
}
inline const ::tros::tros_base::geometry::Shape& Scene::shapes(int index) const {
  // @@protoc_insertion_point(field_get:tros.tros_base.geometry.Scene.shapes)
  return shapes_.Get(index);
}
inline ::tros::tros_base::geometry::Shape* Scene::add_shapes() {
  // @@protoc_insertion_point(field_add:tros.tros_base.geometry.Scene.shapes)
  return shapes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tros::tros_base::geometry::Shape >&
Scene::shapes() const {
  // @@protoc_insertion_point(field_list:tros.tros_base.geometry.Scene.shapes)
  return shapes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace geometry
}  // namespace tros_base
}  // namespace tros

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_base_5fgeometry_2eproto
